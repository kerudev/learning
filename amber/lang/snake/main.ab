import { echo_colored, printf, env_var_get, input_hidden } from "std/env"
import { lowercase } from "std/text"
import { math_floor } from "std/math"

// input
let pressed = ""
let key = "w"

// snake's head
let head = "^"
let head_y = 0
let head_x = 0

// snake's tail
let tail_y = 0
let tail_x = 0

// game grid
let COLUMNS = 0
let LINES = 0

// game state
let score = 0
let is_alive = true
let body = "^"

fun cleanup(code: Num) {
    trust $ tput cnorm $ // show cursor
    trust $ stty echo $  // show input

    exit code
}

fun init_game() {
    trust $ tput clear $ // clear screen and cursor position
    trust $ tput sc $    // save cursor position
    trust $ tput civis $ // hide cursor
    trust $ stty -echo $ // hide input

    // init grid
    for i in 0..LINES {
        for j in 0..COLUMNS {
            trust $ eval "grid{i}[{j}]=' '" $
        }
    }

    // init snake
    head_y = math_floor(LINES / 2)
    head_x = math_floor(COLUMNS / 2)

    trust $ eval "grid{head_y}[{head_x}]='{head}'" $
}

fun draw_grid() {
    trust $ tput rc $ // restore cursor position
    trust $ tput sc $ // save cursor position

    // draw first line
    printf("┌")
    for i in 0..COLUMNS { printf("─") }
    printf("┐\n")

    // draw box
    for i in 0..LINES {
        printf("|")
        trust $ eval "printf '%s' \\\"\\\$\{grid{i}[@]}\\\"" $
        printf("|\n")
    }

    // draw last line
    printf("└")
    for i in 0..COLUMNS { printf("─") }
    printf("┘")
}

fun read_key() {
    trust $ read -rsn1 -t 0.001 {nameof pressed} $

    if len(pressed) {
        key = lowercase(pressed)
    }
}

fun set_head() {
    if {
        key == "w" and head != "v": head = "^"
        key == "s" and head != "^": head = "v"
        key == "a" and head != ">": head = "<"
        key == "d" and head != "<": head = ">"
        key == "q": cleanup(0)
    }
}

fun move_snake() {
    let prev_x = head_x
    let prev_y = head_y
    let prev_char = " "

    if {
        head == "^": head_y -= 1
        head == "v": head_y += 1
        head == "<": head_x -= 1
        head == ">": head_x += 1
    }

    if head_y < 0 or head_y > LINES - 1 or head_x < 0 or head_x > COLUMNS - 1 {
        echo_colored("You died! Your score was {score}", 31)
        cleanup(1)
    }

    $ eval "[[ \\\"\\\$\{grid{head_y}[{head_x}]}\\\" != 'o' ]]" $ failed {
        echo_colored("You died! Your score was {score}", 31)
        cleanup(1)
    }

    $ eval "[[ \\\"\\\$\{grid{head_y}[{head_x}]}\\\" != '@' ]]" $ failed {
        prev_char = "o"
        score += 1
    }

    // body += head

    trust $ eval "grid{prev_y}[{prev_x}]='{prev_char}'" $
    trust $ eval "grid{head_y}[{head_x}]='{head}'" $
}

fun spawn_food() {
    let rnd_x = 0
    let rnd_y = 0

    loop {
        rnd_x = trust env_var_get("RANDOM") as Num % LINES
        rnd_y = trust env_var_get("RANDOM") as Num % COLUMNS

        $ eval "[[ \\\"\\\$\{grid{rnd_x}[{rnd_y}]}\\\" = \\\" \\\" ]]" $ failed { continue }

        break
    }

    trust $ eval "grid{rnd_x}[{rnd_y}]=@" $
}

main {
    COLUMNS = trust $ tput cols $ as Num - 2
    LINES = trust $ tput lines $ as Num - 2

    if COLUMNS < 3 or LINES < 3 {
        echo_colored("Please resize your terminal to be at least 33x5", 31)
        echo_colored("Current size: {COLUMNS}x{LINES}", 34)
        exit 0
    }

    init_game()
    draw_grid()

    loop {
        read_key()
        set_head()
        spawn_food()
        move_snake()
        draw_grid()

        trust $ sleep 0.1 $

        if not is_alive { break }
    }
}
